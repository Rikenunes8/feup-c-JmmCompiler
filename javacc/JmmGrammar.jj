PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false; // tokens are no longer nodes in the tree


SKIP: < " " | "\t" | "\r" | "\n" | "\r\n" >
    | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
    | <"/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >
    | <"/*" ( ~["*"] | ("*")+ ~["*","/"] )* ("*")*> 
;

TOKEN :
        < IMPORT    : "import" >
    |   < CLASS     : "class" >
    |   < EXTENDS   : "extends" >
    |   < PUBLIC    : "public" >
    |   < THIS      : "this" >
    |   < NEW       : "new" >
    |   < LENGTH    : "length" >
    |   < RETURN    : "return" >
    |   < STATIC    : "static" >
    |   < VOID      : "void" >
    |   < MAIN      : "main" >
    |   < STRING    : "String" >
    |   < IF        : "if" >
    |   < ELSE      : "else" >
    |   < WHILE     : "while" >
    |   < FOR       : "for" >

    |   < INT       : "int" >
    |   < BOOLEAN   : "boolean" >

    |   < DOT       : "." >
    |   < COMMA     : "," >
    |   < SEMICOLON : ";" >

    |   < OPEN_PAREN    : "(" >
    |   < CLOSE_PAREN   : ")" >
    |   < OPEN_SQR_BRACKET    : "[" >
    |   < CLOSE_SQR_BRACKET   : "]" >
    |   < OPEN_CRV_BRACKET    : "{" >
    |   < CLOSE_CRV_BRACKET   : "}" >

	|   < ADD   : "+" >
	|   < SUB   : "-" >
	|   < MUL   : "*" >
	|   < DIV   : "/" >

	|   < AND   : "&&" >
	|   < LT    : "<" >
	|   < TRUE  : "true" >
	|   < FALSE : "false" >
	|   < NOT   : "!" >
	|   < EQ    : "=" >

	|   < IDENTIFIER : ( < LETTER > | "_" ) (< LETTER > | < DIGIT > | "_")* >
	|   < INTEGER   : (< DIGIT >)+ >
	|   < DIGIT     : ["0" - "9"] >
	|   < LETTER    : ["a" - "z" , "A" - "Z"] >
;

Program : ImportDeclaration ClassDeclaration <EOF> ;

// ({ jjtThis.put("value", lastConsumedToken.getImage()); })
ImportDeclaration #void :
	( (< IMPORT > 
        < IDENTIFIER > ( < DOT > < IDENTIFIER > )* 
    < SEMICOLON > ) #ImportStatement )*
;

ClassDeclaration :
    < CLASS > < IDENTIFIER > (< EXTENDS > < IDENTIFIER >)?
    < OPEN_CRV_BRACKET >
        ( VarDeclaration )*
        ( MethodDeclaration )*
    < CLOSE_CRV_BRACKET >
;

MethodDeclaration :
    < PUBLIC > (
    Type < IDENTIFIER >
    < OPEN_PAREN > (Type < IDENTIFIER > (< COMMA > Type < IDENTIFIER >)* )? < CLOSE_PAREN >
    < OPEN_CRV_BRACKET > ( SCAN 2 VarDeclaration )* ( Statement )* < RETURN > Expression < SEMICOLON > < CLOSE_CRV_BRACKET >
    |
    < STATIC > < VOID > < MAIN >
    < OPEN_PAREN > <STRING> < OPEN_SQR_BRACKET > < CLOSE_SQR_BRACKET > < IDENTIFIER > < CLOSE_PAREN >
    < OPEN_CRV_BRACKET > ( SCAN 2 VarDeclaration )* ( Statement )* < CLOSE_CRV_BRACKET > )
;

VarDeclaration :
    (Type < IDENTIFIER > < SEMICOLON >)
;

Statement #void : 
        < OPEN_CRV_BRACKET > ( Statement )* < CLOSE_CRV_BRACKET > #NestedStatement
    |   ( < IF > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement < ELSE > Statement ) #IfStatement
    |   ( < WHILE > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement ) #WhileStatement
    |   SCAN 2 (< IDENTIFIER > (< OPEN_SQR_BRACKET > Expression < CLOSE_SQR_BRACKET >)? < EQ > Expression < SEMICOLON >) #AssignmentStatement
    |   Expression < SEMICOLON >
;

Type #void : 
		< INT > (< OPEN_SQR_BRACKET > < CLOSE_SQR_BRACKET >)?
    |   < BOOLEAN >
    |   < IDENTIFIER >
;

Expression #void:         AndExpression ;
AndExpression #void:      LessThanExpression (< AND > LessThanExpression #AndExp(2))* ;
LessThanExpression #void: AddSubExpression (< LT > AddSubExpression #LessExp(2))* ;
AddSubExpression #void:   MulDivExpression (< ADD > MulDivExpression #AddExp(2) | < SUB > MulDivExpression #SubExp(2))* ;
MulDivExpression #void:   UnaryExpression (< MUL > UnaryExpression #MultExp(2) | < DIV > UnaryExpression #DivExp(2))* ;
UnaryExpression #void:    (< NOT > UnaryExpression #NotExp(1) | LastLevelExpression) ;
LastLevelExpression #void: FinalExpression (< DOT > DotExpression #DotExp(2) | ArrExpression #ArrayAccessExp(2) )* ;
ArrExpression #void:      < OPEN_SQR_BRACKET > Expression < CLOSE_SQR_BRACKET > ;

DotExpression #void:
        < LENGTH > #LengthToken
    |   (< IDENTIFIER > < OPEN_PAREN > (Expression (< COMMA > Expression)* )? < CLOSE_PAREN >) #FunctionCall
;


FinalExpression #void:
        < INTEGER > #NumberToken
    |   < TRUE > #TrueToken
    |   < FALSE > #FalseToken
    |   < THIS > #ThisToken
    |   < NEW > NewExpression
    |   < OPEN_PAREN > Expression < CLOSE_PAREN >
    |   < IDENTIFIER > #IdentifierToken
;

NewExpression #void:
        < INT > < OPEN_SQR_BRACKET > #NewArray Expression < CLOSE_SQR_BRACKET >
    |   < IDENTIFIER > #NewObject < OPEN_PAREN > < CLOSE_PAREN >
;


// in order to use jjtThis 

INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}