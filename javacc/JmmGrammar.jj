PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
        < IMPORT    : "import" >
    |   < CLASS     : "class" >
    |   < EXTENDS   : "extends" >
    |   < PUBLIC    : "public" >
    |   < THIS      : "this" >
    |   < NEW       : "new" >
    |   < LENGTH    : "length" >
    |   < RETURN    : "return" >
    |   < STATIC    : "static" >
    |   < VOID      : "void" >
    |   < MAIN      : "main" >
    |   < STRING    : "String" >
    |   < IF        : "if" >
    |   < ELSE      : "else" >
    |   < WHILE     : "while" >
    |   < FOR       : "for" >

    |   < INT       : "int" >
    |   < BOOLEAN   : "boolean" >

    |   < DOT       : "." >
    |   < COMMA     : "," >
    |   < SEMICOLON : ";" >

    |   < OPEN_PAREN    : "(" >
    |   < CLOSE_PAREN   : ")" >
    |   < OPEN_SQR_BRACKET    : "[" >
    |   < CLOSE_SQR_BRACKET   : "]" >
    |   < OPEN_CRV_BRACKET    : "{" >
    |   < CLOSE_CRV_BRACKET   : "}" >

	|   < ADD   : "+" >
	|   < SUB   : "-" >
	|   < MUL   : "*" >
	|   < DIV   : "/" >

	|   < AND   : "&&" >
	|   < LT    : "<" >
	|   < TRUE  : "true" >
	|   < FALSE : "false" >
	|   < NOT   : "!" >
	|   < EQ    : "=" >

	|   < IDENTIFIER : (< LETTER >) (< LETTER > | < DIGIT > | "_")* >
	|   < INTEGER   : (< DIGIT >)+ >
	|   < DIGIT     : ["0" - "9"] >
	|   < LETTER    : ["a" - "z" , "A" - "Z"] >
;

Program : ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration : 
	( < IMPORT > < IDENTIFIER > ( < DOT > < IDENTIFIER > )* < SEMICOLON > )*
;

ClassDeclaration :
    < CLASS > < IDENTIFIER > (< EXTENDS > < IDENTIFIER >)?
    < OPEN_CRV_BRACKET >
        ( VarDeclaration )*
        ( MethodDeclaration )*
    < CLOSE_CRV_BRACKET >
;

MethodDeclaration :
    < PUBLIC > (
    Type < IDENTIFIER >
    < OPEN_PAREN > (Type < IDENTIFIER > (< COMMA > Type < IDENTIFIER >)* )? < CLOSE_PAREN >
    < OPEN_CRV_BRACKET > ( VarDeclaration )* ( Statement )* < RETURN > Expression < SEMICOLON > < CLOSE_CRV_BRACKET >
    |
    < STATIC > < VOID > < MAIN >
    < OPEN_PAREN > <STRING> < OPEN_SQR_BRACKET > < CLOSE_SQR_BRACKET > < IDENTIFIER > < CLOSE_PAREN >
    < OPEN_CRV_BRACKET > ( VarDeclaration )* ( Statement )* < CLOSE_CRV_BRACKET > )
;

VarDeclaration :
    Type < IDENTIFIER > < SEMICOLON >
;

Statement: 
        < OPEN_CRV_BRACKET > Statement < CLOSE_CRV_BRACKET > 
    |   < IF > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement < ELSE > Statement
    |   < WHILE > < OPEN_PAREN > Expression < CLOSE_PAREN > Statement
    |   (SCAN 2 < IDENTIFIER > (< OPEN_SQR_BRACKET > Expression < CLOSE_SQR_BRACKET >)? < EQ > Expression < SEMICOLON >
    |    Expression < SEMICOLON >)
;

Type : 
		< INT > (< OPEN_SQR_BRACKET > < CLOSE_SQR_BRACKET >)?
    |   < BOOLEAN >
    |   < IDENTIFIER >
;

Expression:         AndExpression ;
AndExpression:      LessThanExpression (< AND > LessThanExpression)* ;
LessThanExpression: AddSubExpression (< LT > AddSubExpression)* ;
AddSubExpression:   MulDivExpression (< ADD > MulDivExpression | < SUB > MulDivExpression)* ;
MulDivExpression:   UnaryExpression (< MUL > UnaryExpression | < DIV > UnaryExpression)* ;
UnaryExpression:    (< NOT > Expression | LastLevelExpression) ;
LastLevelExpression:    FinalExpression (< DOT > DotExpression | ArrExpression)* ;
ArrExpression:      < OPEN_SQR_BRACKET > Expression < CLOSE_SQR_BRACKET > ;

DotExpression:
        < LENGTH >
    |   < IDENTIFIER > < OPEN_PAREN > ( Expression (< COMMA > Expression)* )? < CLOSE_PAREN >
;


FinalExpression :
        < INTEGER >
    |   < TRUE >
    |   < FALSE >
    |   < THIS >
    |   < NEW > NewExpression
    |   < OPEN_PAREN > Expression < CLOSE_PAREN >
    |   < IDENTIFIER >
;

NewExpression :
        < INT > < OPEN_SQR_BRACKET > Expression < CLOSE_SQR_BRACKET >
    |   < IDENTIFIER > < OPEN_PAREN > < CLOSE_PAREN >
;
